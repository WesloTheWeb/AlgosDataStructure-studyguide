/*#############
1. Given a sorted linked list of unique integers, remove a target node from the list recursively. 
If the list does not contain the target element, do nothing.
#############*/
function solution(list, target) {
    // write code here
};

/*#############
2. Given a linked list, return the kth element from the end of the list.
#############*/

function solution(list, k) {
  // write code here
}

/*####################
3. Reverse a given linked list:
Singly-linked lists are already defined with this interface:
function ListNode(x) {
  this.value = x;
  this.next = null;
}
#####################*/
function solution(list) {
    // write code here
}


/*#############
4. Q. Given an unsorted array, perform merge sort in ascending order.
#############*/
function solution(array) {
    // write code here
}

/*#############
5. Given a sorted array of unique positive integers and a target integer, check if the array contains a target 
using binary search and return its index.
If the array does not contain the target, return -1.
Indexes (indices) follow the zero-based numbering rule (i.e. the index of the first element of an array is 0, not 1).
#############*/
function solution(array, target) {
      // write code here
};

/*#############
6. Given a binary tree, count the number of elements in the tree recursively.
#############*/
 //
// Binary trees are already defined with this interface:
// function Tree(x) {
//   this.value = x;
//   this.left = null;
//   this.right = null;
// }
function solution(root) {
    // write code here
}

/*#############
7. Given a binary tree, find the height of the tree.
#############*/
//
// Binary trees are already defined with this interface:
// function Tree(x) {
//   this.value = x;
//   this.left = null;
//   this.right = null;
// }
function solution(root) {
    // write code here
}

/*#############
8. Q. Given a binary search tree and a target integer, check if the tree contains a target.
#############*/
//
// Binary trees are already defined with this interface:
// function Tree(x) {
//   this.value = x;
//   this.left = null;
//   this.right = null;
// }
function solution(root, target) {
    // write code here
}

/*#############
9. Given a binary tree, determine if it is a valid BST.
#############*/
//
// Binary trees are already defined with this interface:
// function Tree(x) {
//   this.value = x;
//   this.left = null;
//   this.right = null;
// }
function solution(root) {
    // write code here
}

/*#############
10. Given a target n, find the n-th Fibonacci sequence number.
#############*/
/*  APPROACH
- How can reverse if its a singly linked list?
unless we can add a prev this.prev? 
*/
function solution(n) {
    // write code here
}